# -*- coding: utf-8 -*-
"""KNN-Weighted_Algorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17etwxG83pWv4_DphM17crqDb7TZMCJa3
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def myknn_weighted(xt, xall, yall, k, K):
    """ KNN ponderado usando a densidade da Gaussiana Multivariada """
    dall = np.sqrt(np.sum((xall - xt) ** 2, axis=1))  # Distâncias Euclidianas
    orddall = np.argsort(dall)  # Índices ordenados pela distância
    nearest_k = orddall[:k]  # Seleciona os k vizinhos mais próximos

    # Calculando pesos usando a função pdfnvar
    weights = np.array([pdfnvar(xall[i], xt, K) for i in nearest_k])

    yhat = np.sign(np.sum(weights * yall[nearest_k]))  # Classificação ponderada
    return yhat

def pdfnvar(x, m, K):
    """ Calcula a densidade de probabilidade da distribuição normal multivariada """
    n = len(x)  # Dimensão dos dados
    K_inv = np.linalg.inv(K)  # Matriz inversa de covariância
    det_K = np.linalg.det(K)  # Determinante da matriz de covariância
    norm_factor = 1 / (np.sqrt((2 * np.pi) ** n * det_K))  # Fator de normalização
    exp_term = np.exp(-0.5 * (x - m).T @ K_inv @ (x - m))  # Termo exponencial
    return norm_factor * exp_term

# Gerando dados
def generate_limited_data(mean, std, size, min_val=0, max_val=6):
    data = np.random.normal(loc=mean, scale=std, size=(size, 2))
    data = np.clip(data, min_val, max_val)  # Corta valores fora do intervalo
    return data

# Parâmetros
k = 20  # Teste 5, 10, 15, 20
h = 2.0 # Teste 0.5, 1.0, 2.0
N = 30
np.random.seed(42)

xc1 = generate_limited_data(mean=2, std=1, size=N)
xc2 = generate_limited_data(mean=4, std=1, size=N)
yc1 = np.full((N, 1), -1)
yc2 = np.full((N, 1), 1)

X_train = np.vstack((xc1, xc2))
y_train = np.vstack((yc1, yc2)).flatten()

# Criando uma matriz de covariância baseada nos dados
K = (h ** 2) * np.eye(2)

# Criando uma grade de pontos dentro do intervalo desejado
x_min, x_max = 0, 6
y_min, y_max = 0, 6
x_values = np.linspace(x_min, x_max, 100)
y_values = np.linspace(y_min, y_max, 100)
X, Y = np.meshgrid(x_values, y_values)

# Calculando a decisão do KNN para cada ponto da grade usando a pdfnvar
M = np.array([myknn_weighted(np.array([x, y]), X_train, y_train, k, K) for x, y in zip(X.ravel(), Y.ravel())])
M = M.reshape(X.shape)

# Superfície de decisão 3D
fig1 = plt.figure(figsize=(8, 6))
ax1 = fig1.add_subplot(111, projection='3d')
ax1.plot_surface(X, Y, M, cmap='coolwarm', edgecolor='none', alpha=0.7)
ax1.scatter(X_train[:, 0], X_train[:, 1], y_train, color='black', marker='o', s=50, label='Pontos de Treino')
ax1.set_xlabel('x1')
ax1.set_ylabel('x2')
ax1.set_zlabel('Classe')
ax1.set_xlim(x_min, x_max)
ax1.set_ylim(y_min, y_max)
ax1.set_zlim(-1, 1)
ax1.set_zticks([-1, 1])
ax1.set_box_aspect([1, 1, 1.2])
ax1.set_title('Superfície de decisão do KNN com ponderação Gaussiana')
ax1.legend()

# Fronteira de decisão 2D
fig2 = plt.figure(figsize=(8, 6))
ax2 = fig2.add_subplot(111)
ax2.contourf(X, Y, M, cmap='coolwarm', alpha=0.7)
ax2.scatter(X_train[:, 0], X_train[:, 1], c=y_train, cmap='coolwarm', edgecolors='black')
ax2.set_xlabel('x1')
ax2.set_ylabel('x2')
ax2.set_xlim(x_min, x_max)
ax2.set_ylim(y_min, y_max)
ax2.set_title('Fronteira de decisão do KNN com ponderação Gaussiana')

plt.tight_layout()
plt.show()